This version of paranoia omits test for extra precise subexpressions
and includes a few additional tests.
0 = 
 0.0000000000000000000000000000000000000000000000000000000000000000000000E0
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 
00000000 00000000 00000000 00000000 00000000 00000000 
1 = 
 1.0000000000000000000000000000000000000000000000000000000000000000000000E0
00000000 00008001 00000000 80000000 00000000 00000000 00000000 00000000 
00000000 00000000 00000000 00000000 00000000 00000000 
1+1 = 
 2.0000000000000000000000000000000000000000000000000000000000000000000000E0
00000000 00008002 00000000 80000000 00000000 00000000 00000000 00000000 
00000000 00000000 00000000 00000000 00000000 00000000 
Program is now RUNNING tests on small integers:
-1, 0, 1/2, 1, 2, 3, 4, 5, 9, 27, 32 & 240 are O.K.

Searching for Radix and Precision.
Radix = 
 2.0000000000000000000000000000000000000000000000000000000000000000000000E0
00000000 00008002 00000000 80000000 00000000 00000000 00000000 00000000 
00000000 00000000 00000000 00000000 00000000 00000000 
Closest relative separation found is U 1 = 
 1.0900377190420865842969737513593110651511287639835344898368128235126807E-106
00000000 00007ea1 00000000 80000000 00000000 00000000 00000000 00000000 
00000000 00000000 00000000 00000000 00000000 00000000 
Recalculating radix and precision.confirms closest relative separation U1 .
Radix confirmed.
The number of significant digits of the Radix is
 3.5200000000000000000000000000000000000000000000000000000000000000000000E2
00000000 00008009 00000000 b0000000 00000000 00000000 00000000 00000000 
00000000 00000000 00000000 00000000 00000000 00000000 
Subtraction appears to be normalized, as it should be.
Checking for guard digit in *, /, and -.
 *, /, and - appear to have guard digits, as they should.
Checking rounding on multiply, divide and add/subtract.
* is neither chopped nor correctly rounded.
/ is neither chopped nor correctly rounded.
Addition/Subtraction appears to round correctly.
Sticky bit used incorrectly or not at all.
lack(s) of guard digits or failure(s) to correctly round or chop
(noted above) count as one flaw in the final tally below

Does Multiplication commute?  Testing on 20 random pairs.
     No failures found in 20 integer pairs.

Running test of square root(x).
Testing if sqrt(X * X) == X for 20 Integers X.
Test for sqrt monotonicity.
sqrt has passed a test for Monotonicity.
Testing whether sqrt is rounded or chopped.
Square root is neither chopped nor correctly rounded.
Observed errors run from 
 0.0000000000000000000000000000000000000000000000000000000000000000000000E0
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 
00000000 00000000 00000000 00000000 00000000 00000000 
	to 
 5.0000000000000000000000000000000000000000000000000000000000000000000000E-1
00000000 00008000 00000000 80000000 00000000 00000000 00000000 00000000 
00000000 00000000 00000000 00000000 00000000 00000000 
ulps.
Testing powers Z^i for small Integers Z and i.
... no discrepancies found.

Seeking Underflow thresholds UfThold and E0.
Smallest strictly positive number found is E0 = 
 7.0648359655776364427774021878587184537374439102725065590941425796903793E-9865
00000000 00000001 00000000 80000000 00000000 00000000 00000000 00000000 
00000000 00000000 00000000 00000000 00000000 00000000 
Since comparison denies Z = 0, evaluating (Z + Z) / Z should be safe.
What the machine gets for (Z + Z) / Z is 
 2.0000000000000000000000000000000000000000000000000000000000000000000000E0
00000000 00008002 00000000 80000000 00000000 00000000 00000000 00000000 
00000000 00000000 00000000 00000000 00000000 00000000 
This is O.K., provided Over/Underflow has NOT just been signaled.

The Underflow threshold is 
 7.0648359655776364427774021878587184537374439102725065590941425796903793E-9865
00000000 00000001 00000000 80000000 00000000 00000000 00000000 00000000 
00000000 00000000 00000000 00000000 00000000 00000000 
below which calculation may suffer larger Relative error than merely roundoff.
Since underflow occurs below the threshold
UfThold = 
 2.0000000000000000000000000000000000000000000000000000000000000000000000E0
00000000 00008002 00000000 80000000 00000000 00000000 00000000 00000000 
00000000 00000000 00000000 00000000 00000000 00000000 
	to the power  
-3.2768000000000000000000000000000000000000000000000000000000000000000000E4
ffffffff 00008010 00000000 80000000 00000000 00000000 00000000 00000000 
00000000 00000000 00000000 00000000 00000000 00000000 
only underflow should afflict the expression 
 2.0000000000000000000000000000000000000000000000000000000000000000000000E0
00000000 00008002 00000000 80000000 00000000 00000000 00000000 00000000 
00000000 00000000 00000000 00000000 00000000 00000000 
	to the power  
-3.2769000000000000000000000000000000000000000000000000000000000000000000E4
ffffffff 00008010 00000000 80010000 00000000 00000000 00000000 00000000 
00000000 00000000 00000000 00000000 00000000 00000000 
Actually calculating yields: 
 0.0000000000000000000000000000000000000000000000000000000000000000000000E0
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 
00000000 00000000 00000000 00000000 00000000 00000000 
This computed value is O.K.

Testing X^((X + 1) / (X - 1)) vs. exp(2) = 
 7.3890560989306502272304274605750078131803155705518473240871278225225738E0
00000000 00008003 00000000 ec7325c6 a6ed6e61 9d1dd103 5b455dd4 23d73d7b 
27910fd6 b3daef2e fa213e29 0f0459ae f0d52adb fed8c516 
	as X -> 1.
Accuracy seems adequate.
Testing powers Z^Q at four nearly extreme values.
 ... no discrepancies found.

Searching for Overflow threshold:
This may generate an error.

qmul overflow error

qmul overflow error
Can `Z = -Y' overflow?
Trying it on Y = 
-1.4154610310449547890015530277449516013481307114723881672343857482723666E9864
ffffffff 00010000 00000000 ffffffff ffffffff ffffffff ffffffff ffffffff 
ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff 
Seems O.K.
Overflow threshold is V  = 
 1.4154610310449547890015530277449516013481307114723881672343857482723666E9864
00000000 00010000 00000000 ffffffff ffffffff ffffffff ffffffff ffffffff 
ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff 
Overflow saturates at V0 = 
 1.4154610310449547890015530277449516013481307114723881672343857482723666E9864
00000000 00010000 00000000 ffffffff ffffffff ffffffff ffffffff ffffffff 
ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff 
No Overflow should be signaled for V * 1 = 
 1.4154610310449547890015530277449516013481307114723881672343857482723666E9864
00000000 00010000 00000000 ffffffff ffffffff ffffffff ffffffff ffffffff 
ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff 
                           nor for V / 1 = 
 1.4154610310449547890015530277449516013481307114723881672343857482723666E9864
00000000 00010000 00000000 ffffffff ffffffff ffffffff ffffffff ffffffff 
ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff 
Any overflow signal separating this * from the one
above is a DEFECT.


The number of  FLAWs  discovered =           1.

The arithmetic diagnosed seems satisfactory though flawed.
END OF TEST.
